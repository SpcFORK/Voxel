import patterns;

import "sources.vxl" as sources;

class Token {
    HUMAN_READABLE_NAME = "token";

    constructor(source) {
        this.value = source;

        this.sourceContainer = null;
        this.location = null;
    }

    matches(token, targetValue) {
        if (!(token inherits this)) {
            return false;
        }

        if (targetValue != null && token.value != targetValue) {
            return false;
        }

        return true;
    }
}

class KeywordToken extends Token {HUMAN_READABLE_NAME = "keyword";}
class AtomToken extends Token {HUMAN_READABLE_NAME = "atom";}
class TypeNameToken extends Token {HUMAN_READABLE_NAME = "type name";}
class StaticMacroToken extends Token {HUMAN_READABLE_NAME = "static function name";}
class BracketToken extends Token {HUMAN_READABLE_NAME = "bracket";}
class DelimeterToken extends Token {HUMAN_READABLE_NAME = "delimeter (,)";}
class StatementDelimeterToken extends Token {HUMAN_READABLE_NAME = "statement delimeter (;)";}
class PropertyAccessorToken extends Token {HUMAN_READABLE_NAME = "property accessor (.)";}
class PropertyDefinerToken extends Token {HUMAN_READABLE_NAME = "property definer (:)";}
class OperatorToken extends Token {HUMAN_READABLE_NAME = "operator";}
class AssignmentOperatorToken extends OperatorToken {HUMAN_READABLE_NAME = "assignment operator";}
class IncrementationOperatorToken extends OperatorToken {}
class IdentifierToken extends Token {HUMAN_READABLE_NAME = "identifier";}

class StringToken extends Token {
    HUMAN_READABLE_NAME = "string literal";

    constructor(value) {
        super(null);

        this.value = value;
    }
}

class NumberToken extends Token {
    HUMAN_READABLE_NAME = "number literal";

    constructor(value) {
        super(null);

        this.value = value;
    }
}

var STRING_CONTENTS_PATTERN = [
    patterns.repeat(1, infinity, [patterns.anyCharExcept("\"'`\\")])
];

var UP_TO_COMMENT_CLOSE_PATTERN = [
    patterns.any([
        patterns.repeat(1, infinity, [
            patterns.anyCharExcept("*/")
        ]),
        patterns.anyChar("*/")
    ])
];

var LINE_COMMENT_PATTERN = [
    patterns.string("//"),
    patterns.repeat(0, infinity, [
        patterns.anyCharExcept("\n")
    ]),
    patterns.any([
        patterns.string("\n"),
        patterns.END
    ])
];

var BRACKET_PATTERN = [patterns.anyChar("({[)}]")];

var KEYWORD_PATTERN = [
    patterns.lookahead(patterns.ALPHA_LOWER),
    patterns.anyString([
        "syscall",
        "as",
        "return",
        "function",
        "class",
        "extends",
        "get",
        "set",
        "this",
        "super",
        "new",
        "var",
        "if",
        "else",
        "while",
        "for",
        "retain",
        "throw",
        "try",
        "catch",
        "enum",
        "break",
        "continue",
        "delete"
    ]),
    patterns.lookahead(patterns.ALPHANUMERIC, false)
];

var ATOM_PATTERN = [
    patterns.lookahead(patterns.ALPHA_LOWER),
    patterns.anyString([
        "null",
        "true",
        "false",
        "infinity",
        "nan"
    ]),
    patterns.lookahead(patterns.ALPHANUMERIC, false)
];

var TYPE_NAME_PATTERN = [
    patterns.lookahead(patterns.ALPHA_UPPER),
    patterns.anyString([
        "Boolean",
        "Byte",
        "Function",
        "ClosureFunction",
        "Number",
        "Buffer",
        "String",
        "Object",
        "List",
        "WeakReference"
    ]),
    patterns.lookahead(patterns.ALPHANUMERIC, false)
];

var STATIC_MACRO_TOKEN = [
    patterns.string("#"),
    patterns.anyString([
        "symbol",
        "usedprop",
        "prop",
        "used"
    ]),
    patterns.lookahead(patterns.ALPHANUMERIC, false)
];

var INCREMENTATION_OPERATOR_PATTERN = [patterns.anyString(["++", "--"])];

var ASSIGNMENT_OPERATOR_PATTERN = [
    patterns.anyString([
        "*=", "/=", "%=", "+=", "-=",
        "<<=", ">>>=", ">>=",
        "&&&=", "|||=", "&&=", "||=", "??=",
        "&=", "^=", "|="
    ])
];

var OPERATOR_PATTERN = [
    patterns.any([
        patterns.anyString([
            "<<", ">>>", ">>",
            "<=", ">=", "!==", "!=", "===", "==",
            "&&&", "|||", "&&", "||", "??",
            "is", "inherits"
        ]),
        patterns.anyChar("+-*/%<>!~&^|?")
    ])
];

var IDENTIFIER_PATTERN = [
    patterns.any([patterns.ALPHA, patterns.anyChar("$_")]),
    patterns.repeat(0, infinity, [
        patterns.any([patterns.ALPHANUMERIC, patterns.anyChar("$_")])
    ])
];

var NUMBER_PATTERN = [
    patterns.any([
        patterns.pattern([
            patterns.repeat(1, infinity, [patterns.DIGIT]),
            patterns.maybe([
                patterns.string("."),
                patterns.repeat(0, infinity, [patterns.DIGIT])
            ])
        ]),
        patterns.pattern([
            patterns.repeat(0, infinity, [patterns.DIGIT]),
            patterns.string("."),
            patterns.maybe([
                patterns.repeat(1, infinity, [patterns.DIGIT])
            ])
        ])
    ]),
    patterns.maybe([
        patterns.anyChar("eE"),
        patterns.maybe([patterns.anyChar("+-")]),
        patterns.repeat(1, infinity, [patterns.DIGIT])
    ])
];

export function tokenise(sourceContainer) {
    var tokens = [];
    var stringLiteralOpener = null;
    var currentString = null;
    var blockCommentDepth = 0;

    var mutables = {
        matchedString: null,
        source: sourceContainer.source,
        previousPosition: 0,
        currentPosition: 0
    };

    function matchToken(pattern) {
        if (pattern is String) {
            if (sourceContainer.source[mutables.currentPosition] != pattern[0]) {
                return false;
            }

            pattern = [patterns.string(pattern)];
        }

        var match = patterns.match(sourceContainer.source, pattern, {matchRest: true, index: mutables.currentPosition});

        if (match.matches) {
            mutables.matchedString = sourceContainer.source.substring(mutables.currentPosition, match.index);
            mutables.previousPosition = mutables.currentPosition;
            mutables.currentPosition = match.index;

            return true;
        }

        return false;
    }

    function addToken(tokenClass, value) {
        value ??= mutables.matchedString;

        var token = new tokenClass(value);

        token.sourceContainer = sourceContainer;
        token.location = mutables.previousPosition;

        tokens.push(token);
    }

    while (mutables.currentPosition < sourceContainer.source.size) {
        if (stringLiteralOpener != null) {
            if (matchToken(STRING_CONTENTS_PATTERN)) {
                currentString += mutables.matchedString;
                continue;
            }

            if (matchToken(stringLiteralOpener)) {
                addToken(StringToken, currentString);

                stringLiteralOpener = null;
                currentString = null;

                continue;
            }

            if (matchToken("\\\\")) {
                currentString += "\\";
                continue;
            }

            if (matchToken("\\r")) {
                currentString += "\r";
                continue;
            }

            if (matchToken("\\n")) {
                currentString += "\n";
                continue;
            }

            if (matchToken("\\\"")) {
                currentString += "\"";
                continue;
            }

            if (matchToken("\\'")) {
                currentString += "'";
                continue;
            }

            if (matchToken("\\`")) {
                currentString += "`";
                continue;
            }

            currentString += sourceContainer.source[mutables.currentPosition++];

            continue;
        }

        if (blockCommentDepth > 0) {
            if (matchToken("*/")) {
                blockCommentDepth--;
                continue;
            }

            matchToken(UP_TO_COMMENT_CLOSE_PATTERN);

            continue;
        }

        if (matchToken(";")) {
            addToken(StatementDelimeterToken);
            continue;
        }

        if (matchToken("...")) {
            addToken(OperatorToken);
            continue;
        }

        if (matchToken(".")) {
            addToken(PropertyAccessorToken);
            continue;
        }

        if (matchToken(",")) {
            addToken(DelimeterToken);
            continue;
        }

        if (matchToken([patterns.WHITESPACE_STRING])) {
            continue;
        }

        if (matchToken(":")) {
            addToken(PropertyDefinerToken);
            continue;
        }

        if (matchToken("=")) {
            addToken(AssignmentOperatorToken);
            continue;
        }

        if (matchToken(BRACKET_PATTERN)) {
            addToken(BracketToken);
            continue;
        }

        if (matchToken("/*")) {
            blockCommentDepth++;
            continue;
        }

        if (matchToken(LINE_COMMENT_PATTERN)) {
            continue;
        }

        if (matchToken(INCREMENTATION_OPERATOR_PATTERN)) {
            addToken(IncrementationOperatorToken);
            continue;
        }

        if (matchToken(ASSIGNMENT_OPERATOR_PATTERN)) {
            addToken(OperatorToken);
            continue;
        }

        if (matchToken(OPERATOR_PATTERN)) {
            addToken(OperatorToken);
            continue;
        }

        if (matchToken(KEYWORD_PATTERN)) {
            addToken(KeywordToken);
            continue;
        }

        if (matchToken(ATOM_PATTERN)) {
            addToken(AtomToken);
            continue;
        }

        if (matchToken(TYPE_NAME_PATTERN)) {
            addToken(TypeNameToken);
            continue;
        }

        if (matchToken(IDENTIFIER_PATTERN)) {
            addToken(IdentifierToken);
            continue;
        }

        if (matchToken(STATIC_MACRO_TOKEN)) {
            addToken(StaticMacroToken);
            continue;
        }

        if (matchToken([patterns.anyChar("\"'`")])) {
            stringLiteralOpener = sourceContainer.source.substring(mutables.previousPosition, mutables.currentPosition);
            continue;
        }

        if (matchToken(NUMBER_PATTERN)) {
            addToken(NumberToken, mutables.matchedString.toNumber());
            continue;
        }

        // TODO: Allow base conversions in Voxel to parse binary, octal and hexadecimal numbers

        throw new sources.SourceError("Invalid syntax", sourceContainer, mutables.currentPosition);
    }

    return tokens;
}