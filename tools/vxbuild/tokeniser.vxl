import patterns;

import "sources.vxl" as sources;

class Token {
    HUMAN_READABLE_NAME = "token";

    constructor(source) {
        this.value = source;

        this.sourceContainer = null;
        this.location = null;
    }

    matches(token, targetValue) {
        if (!(token inherits this)) {
            return false;
        }

        if (targetValue != null && token.value != targetValue) {
            return false;
        }

        return true;
    }
}

class KeywordToken extends Token {HUMAN_READABLE_NAME = "keyword";}
class AtomToken extends Token {HUMAN_READABLE_NAME = "atom";}
class TypeNameToken extends Token {HUMAN_READABLE_NAME = "type name";}
class StaticMacroToken extends Token {HUMAN_READABLE_NAME = "static function name";}
class BracketToken extends Token {HUMAN_READABLE_NAME = "bracket";}
class DelimeterToken extends Token {HUMAN_READABLE_NAME = "delimeter (,)";}
class StatementDelimeterToken extends Token {HUMAN_READABLE_NAME = "statement delimeter (;)";}
class PropertyAccessorToken extends Token {HUMAN_READABLE_NAME = "property accessor (.)";}
class PropertyDefinerToken extends Token {HUMAN_READABLE_NAME = "property definer (:)";}
class OperatorToken extends Token {HUMAN_READABLE_NAME = "operator";}
class AssignmentOperatorToken extends OperatorToken {HUMAN_READABLE_NAME = "assignment operator";}
class IncrementationOperatorToken extends OperatorToken {}
class IdentifierToken extends Token {HUMAN_READABLE_NAME = "identifier";}

class StringToken extends Token {
    HUMAN_READABLE_NAME = "string literal";

    constructor(value) {
        super(null);

        this.value = value;
    }
}

class NumberToken extends Token {
    HUMAN_READABLE_NAME = "number literal";

    constructor(value) {
        super(null);

        this.value = value;
    }
}

var KEYWORDS = [
    "syscall",
    "as",
    "return",
    "function",
    "class",
    "extends",
    "get",
    "set",
    "this",
    "super",
    "new",
    "var",
    "if",
    "else",
    "while",
    "for",
    "retain",
    "throw",
    "try",
    "catch",
    "enum",
    "break",
    "continue",
    "delete"
];

var ATOMS = [
    "null",
    "true",
    "false",
    "infinity",
    "nan"
];

var TYPE_NAMES = [
    "Boolean",
    "Byte",
    "Function",
    "ClosureFunction",
    "Number",
    "Buffer",
    "String",
    "Object",
    "List",
    "WeakReference"
];

var NAMED_OPERATORS = ["is", "inherits"];

var STRING_CONTENTS_PATTERN = [
    patterns.repeat(1, infinity, [patterns.anyCharExcept("\"'`\\")])
];

var UP_TO_COMMENT_CLOSE_PATTERN = [
    patterns.any([
        patterns.repeat(1, infinity, [
            patterns.anyCharExcept("*/")
        ]),
        patterns.anyChar("*/")
    ])
];

var UP_TO_LINE_COMMEND_END_PATTERN = [
    patterns.repeat(0, infinity, [
        patterns.anyCharExcept("\n")
    ]),
    patterns.any([
        patterns.string("\n"),
        patterns.END
    ])
];

var BRACKET_PATTERN = [patterns.anyChar("({[)}]")];

var STATIC_MACRO_TOKEN = [
    patterns.string("#"),
    patterns.anyString([
        "symbol",
        "usedprop",
        "prop",
        "used"
    ]),
    patterns.lookahead(patterns.ALPHANUMERIC, false)
];

var INCREMENTATION_OPERATOR_PATTERN = [patterns.anyString(["++", "--"])];

var ASSIGNMENT_OPERATOR_PATTERN = [
    patterns.anyString([
        "*=", "/=", "%=", "+=", "-=",
        "<<=", ">>>=", ">>=",
        "&&&=", "|||=", "&&=", "||=", "??=",
        "&=", "^=", "|="
    ])
];

var OPERATOR_PATTERN = [
    patterns.any([
        patterns.anyString([
            "<<", ">>>", ">>",
            "<=", ">=", "!==", "!=", "===", "==",
            "&&&", "|||", "&&", "||", "??"
        ]),
        patterns.anyChar("+-*/%<>!~&^|?")
    ])
];

var IDENTIFIER_PATTERN = [
    patterns.any([patterns.ALPHA, patterns.anyChar("$_")]),
    patterns.repeat(0, infinity, [
        patterns.any([patterns.ALPHANUMERIC, patterns.anyChar("$_")])
    ])
];

var NUMBER_PATTERN = [
    patterns.any([
        patterns.pattern([
            patterns.repeat(1, infinity, [patterns.DIGIT]),
            patterns.maybe([
                patterns.string("."),
                patterns.repeat(0, infinity, [patterns.DIGIT])
            ])
        ]),
        patterns.pattern([
            patterns.repeat(0, infinity, [patterns.DIGIT]),
            patterns.string("."),
            patterns.maybe([
                patterns.repeat(1, infinity, [patterns.DIGIT])
            ])
        ])
    ]),
    patterns.maybe([
        patterns.anyChar("eE"),
        patterns.maybe([patterns.anyChar("+-")]),
        patterns.repeat(1, infinity, [patterns.DIGIT])
    ])
];

export function tokenise(sourceContainer) {
    var tokens = [];
    var stringLiteralOpener = null;
    var currentString = null;
    var blockCommentDepth = 0;
    var source = sourceContainer.source;
    var sourceBuffer = source.toBuffer();

    var mutables = {
        matchedString: null,
        previousPosition: 0,
        currentPosition: 0
    };

    function matchToken(pattern) {
        var position = mutables.currentPosition;

        if (pattern is String) {
            var matchCandidate = source.substring(position, position + pattern.size);

            if (matchCandidate == pattern) {
                mutables.matchedString = matchCandidate;
                mutables.previousPosition = position;
                mutables.currentPosition += pattern.size;

                return true;
            }
            
            return false;
        }

        var match = patterns.match(sourceBuffer, pattern, {matchRest: true, index: position});

        if (match.matches) {
            mutables.matchedString = source.substring(position, match.index);
            mutables.previousPosition = position;
            mutables.currentPosition = match.index;

            return true;
        }

        return false;
    }

    function addToken(tokenClass, value) {
        value ??= mutables.matchedString;

        var token = new tokenClass(value);

        token.sourceContainer = sourceContainer;
        token.location = mutables.previousPosition;

        tokens.push(token);
    }

    while (mutables.currentPosition < source.size) {
        if (stringLiteralOpener != null) {
            if (matchToken(STRING_CONTENTS_PATTERN)) {
                currentString += mutables.matchedString;
                continue;
            }

            if (matchToken(stringLiteralOpener)) {
                addToken(StringToken, currentString);

                stringLiteralOpener = null;
                currentString = null;

                continue;
            }

            if (matchToken("\\\\")) {
                currentString += "\\";
                continue;
            }

            if (matchToken("\\r")) {
                currentString += "\r";
                continue;
            }

            if (matchToken("\\n")) {
                currentString += "\n";
                continue;
            }

            if (matchToken("\\\"")) {
                currentString += "\"";
                continue;
            }

            if (matchToken("\\'")) {
                currentString += "'";
                continue;
            }

            if (matchToken("\\`")) {
                currentString += "`";
                continue;
            }

            currentString += source[mutables.currentPosition++];

            continue;
        }

        if (blockCommentDepth > 0) {
            if (matchToken("*/")) {
                blockCommentDepth--;
                continue;
            }

            matchToken(UP_TO_COMMENT_CLOSE_PATTERN);

            continue;
        }

        if (matchToken(IDENTIFIER_PATTERN)) {
            if (KEYWORDS.contains(matchedString)) {
                addToken(KeywordToken);
                continue;
            }

            if (ATOMS.contains(matchedString)) {
                addToken(AtomToken);
                continue;
            }

            if (TYPE_NAMES.contains(matchedString)) {
                addToken(TypeNameToken);
                continue;
            }

            if (NAMED_OPERATORS.contains(matchedString)) {
                addToken(OperatorToken);
                continue;
            }

            addToken(IdentifierToken);
            continue;
        }

        if (matchToken(";")) {
            addToken(StatementDelimeterToken);
            continue;
        }

        if (matchToken("...")) {
            addToken(OperatorToken);
            continue;
        }

        if (matchToken(".")) {
            addToken(PropertyAccessorToken);
            continue;
        }

        if (matchToken(",")) {
            addToken(DelimeterToken);
            continue;
        }

        if (matchToken([patterns.WHITESPACE_STRING])) {
            continue;
        }

        if (matchToken(":")) {
            addToken(PropertyDefinerToken);
            continue;
        }

        if (matchToken("=")) {
            addToken(AssignmentOperatorToken);
            continue;
        }

        if (matchToken(BRACKET_PATTERN)) {
            addToken(BracketToken);
            continue;
        }

        if (matchToken("/*")) {
            blockCommentDepth++;
            continue;
        }

        if (matchToken("//")) {
            matchToken(UP_TO_LINE_COMMEND_END_PATTERN);
            continue;
        }

        if (matchToken("++") || matchToken("--")) {
            addToken(IncrementationOperatorToken);
            continue;
        }

        if (matchToken(ASSIGNMENT_OPERATOR_PATTERN)) {
            addToken(OperatorToken);
            continue;
        }

        if (matchToken(OPERATOR_PATTERN)) {
            addToken(OperatorToken);
            continue;
        }

        if (matchToken(STATIC_MACRO_TOKEN)) {
            addToken(StaticMacroToken);
            continue;
        }

        if (matchToken([patterns.anyChar("\"'`")])) {
            stringLiteralOpener = sourceContainer.source.substring(mutables.previousPosition, mutables.currentPosition);
            continue;
        }

        if (matchToken(NUMBER_PATTERN)) {
            addToken(NumberToken, mutables.matchedString.toNumber());
            continue;
        }

        // TODO: Allow base conversions in Voxel to parse binary, octal and hexadecimal numbers

        throw new sources.SourceError("Invalid syntax", sourceContainer, mutables.currentPosition);
    }

    return tokens;
}